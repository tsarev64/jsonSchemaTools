import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import json
import jsonschema
from jsonschema.exceptions import ValidationError, best_match
from hypothesis.strategies import from_regex
from typing import Any, Dict, List, Tuple


DiffEntry = Tuple[str, str, str] 


class LineNumberedText(ttk.Frame):


    def __init__(self, parent: tk.Misc, wrap=tk.WORD):
        super().__init__(parent)

        self.text = tk.Text(self, wrap=wrap, undo=True)
        self.linenumbers = tk.Text(
            self,
            width=4,
            padx=4,
            takefocus=0,
            border=0,
            state="disabled",
            background="#f0f0f0",
            foreground="#808080",
        )

        self.vscroll = ttk.Scrollbar(self, orient="vertical", command=self._on_vscroll)

        self.linenumbers.grid(row=0, column=0, sticky="ns")
        self.text.grid(row=0, column=1, sticky="nsew")
        self.vscroll.grid(row=0, column=2, sticky="ns")

        self.columnconfigure(1, weight=1)
        self.rowconfigure(0, weight=1)

        self.text.configure(yscrollcommand=self._on_textscroll)

        self.text.bind("<KeyRelease>", self._on_change)
        self.text.bind("<MouseWheel>", self._on_change)
        self.text.bind("<ButtonRelease-1>", self._on_change)
        self.text.bind("<Configure>", self._on_change)

        self.text.bind("<Button-4>", self._on_change)
        self.text.bind("<Button-5>", self._on_change)

        self._update_linenumbers()

    def _on_vscroll(self, *args):
        self.text.yview(*args)
        self.linenumbers.yview(*args)

    def _on_textscroll(self, *args):
        # args = (first, last)
        self.vscroll.set(*args)
        self.linenumbers.yview_moveto(args[0])

    def _on_change(self, _event=None):
        self._update_linenumbers()

    def _update_linenumbers(self):
        end_index = self.text.index("end-1c")
        line_count = int(end_index.split(".")[0])
        numbers = "\n".join(str(i) for i in range(1, line_count + 1)) + "\n"

        self.linenumbers.configure(state="normal")
        self.linenumbers.delete("1.0", tk.END)
        self.linenumbers.insert("1.0", numbers)
        self.linenumbers.configure(state="disabled")


class SchemaToolsFrame(ttk.Frame):


    def __init__(self, parent: tk.Misc):
        super().__init__(parent)

        self.current_schema: Dict[str, Any] | None = None
        self.current_errors: List[DiffEntry] = []

        top_frame = ttk.Frame(self)
        top_frame.pack(fill=tk.X, pady=(0, 5))

        self.schema_path_var = tk.StringVar()
        ttk.Label(top_frame, text="Файл схемы:").grid(row=0, column=0, sticky="w")
        ttk.Entry(top_frame, textvariable=self.schema_path_var).grid(row=0, column=1, sticky="we", padx=(5, 5))
        ttk.Button(top_frame, text="Открыть...", command=self.load_schema_from_file).grid(row=0, column=2)
        top_frame.columnconfigure(1, weight=1)

        paned = ttk.PanedWindow(self, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True, pady=5)

        left_frame = ttk.Frame(paned)
        right_frame = ttk.Frame(paned)
        paned.add(left_frame, weight=1)
        paned.add(right_frame, weight=1)

        ttk.Label(left_frame, text="JSON Schema").pack(anchor=tk.W)
        self.schema_text = LineNumberedText(left_frame, wrap=tk.WORD)
        self.schema_text.pack(fill=tk.BOTH, expand=True, padx=(0, 5), pady=(5, 5))
        self.schema_text_widget = self.schema_text.text

        ttk.Label(right_frame, text="Сообщение / сгенерированный пример").pack(anchor=tk.W)
        self.instance_text = LineNumberedText(right_frame, wrap=tk.WORD)
        self.instance_text.pack(fill=tk.BOTH, expand=True, padx=(5, 0), pady=(5, 5))
        self.instance_text_widget = self.instance_text.text

        self.schema_text_widget.tag_configure("hl", background="#fff8b3")
        self.instance_text_widget.tag_configure("hl", background="#fff8b3")

        btn_frame = ttk.Frame(self)
        btn_frame.pack(fill=tk.X, pady=(5, 0))

        ttk.Button(btn_frame, text="Сгенерировать пример по схеме", command=self.generate_example).pack(
            side=tk.LEFT, padx=(0, 5)
        )
        ttk.Button(btn_frame, text="Проверить сообщение", command=self.validate).pack(
            side=tk.LEFT, padx=(0, 5)
        )
        ttk.Button(btn_frame, text="Сохранить сообщение", command=self.save_instance).pack(
            side=tk.LEFT, padx=(0, 5)
        )

        error_frame = ttk.Frame(self)
        error_frame.pack(fill=tk.BOTH, expand=True, pady=(8, 0))

        ttk.Label(error_frame, text="Результат проверки:").pack(anchor=tk.W)
        self.error_output = LineNumberedText(error_frame, wrap=tk.WORD)
        self.error_output.pack(fill=tk.BOTH, expand=True)
        self.error_text = self.error_output.text
        self.error_text.tag_configure("error", foreground="#8B0000")
        self.error_text.tag_configure("info", foreground="#000080")

    def load_schema_from_file(self):
        path = filedialog.askopenfilename(
            title="Выберите файл JSON схемы",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = f.read()
            self.schema_text_widget.delete("1.0", tk.END)
            self.schema_text_widget.insert(tk.END, content)
            self.schema_path_var.set(path)
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось прочитать файл:\n{e}")

    def generate_example(self):
        schema_str = self.schema_text_widget.get("1.0", tk.END).strip()
        if not schema_str:
            messagebox.showwarning("Ошибка", "Пожалуйста, загрузите или введите JSON-схему.")
            return
        try:
            schema = json.loads(schema_str)
            self.current_schema = schema
            example = self._generate_from_schema(schema)
            self.instance_text_widget.delete("1.0", tk.END)
            self.instance_text_widget.insert(
                tk.END, json.dumps(example, indent=2, ensure_ascii=False)
            )
        except Exception as e:
            messagebox.showerror("Ошибка генерации", f"Не удалось сгенерировать пример:\n{e}")

    def _resolve_ref(self, ref_path: str) -> Any:
        """Разрешает $ref внутри текущей схемы."""
        if not self.current_schema or not ref_path.startswith("#/"):
            return None
        parts = ref_path[2:].split("/")
        current: Any = self.current_schema
        for part in parts:
            if not part:
                continue
            if isinstance(current, dict) and part in current:
                current = current[part]
            else:
                return None
        return current

    def _generate_from_schema(self, schema: Any) -> Any:
        if isinstance(schema, dict) and "$ref" in schema:
            ref_schema = self._resolve_ref(schema["$ref"])
            if ref_schema:
                return self._generate_from_schema(ref_schema)
            return {}

        if isinstance(schema, dict) and "anyOf" in schema:
            for sub_schema in schema["anyOf"]:
                try:
                    return self._generate_from_schema(sub_schema)
                except Exception:
                    continue
            return {}

        if isinstance(schema, dict) and "oneOf" in schema:
            for sub_schema in schema["oneOf"]:
                try:
                    return self._generate_from_schema(sub_schema)
                except Exception:
                    continue
            return {}

        if isinstance(schema, dict) and "allOf" in schema:
            result: Dict[str, Any] = {}
            for sub_schema in schema["allOf"]:
                try:
                    sub_result = self._generate_from_schema(sub_schema)
                    if isinstance(sub_result, dict):
                        result.update(sub_result)
                except Exception:
                    continue
            return result

        if isinstance(schema, dict) and "type" not in schema:
            if "properties" in schema:
                schema = dict(schema)
                schema["type"] = "object"

        if isinstance(schema, dict) and "type" not in schema:
            return {}

        schema_type = schema.get("type")

        if isinstance(schema, dict) and "enum" in schema:
            return schema["enum"][0] if schema["enum"] else None

        if isinstance(schema, dict) and "const" in schema:
            return schema["const"]

        if schema_type == "object":
            result: Dict[str, Any] = {}
            properties = schema.get("properties", {}) or {}
            required = set(schema.get("required", []))

            for prop_name, prop_schema in properties.items():
                result[prop_name] = self._generate_from_schema(prop_schema)

            for req in required:
                if req not in result:
                    result[req] = self._generate_from_schema(properties.get(req, {}))

            return result

        if schema_type == "array":
            items_schema = schema.get("items", {}) or {}
            min_items = schema.get("minItems", 0)
            max_items = schema.get("maxItems", 1)
            unique_items = schema.get("uniqueItems", False)

            count = max(min_items, 1)
            if max_items and count > max_items:
                count = max_items

            arr: List[Any] = []
            for _ in range(count):
                arr.append(self._generate_from_schema(items_schema))

            if unique_items:
                arr = list({json.dumps(item, sort_keys=True): item for item in arr}.values())
            return arr

        if schema_type == "string":
            pattern = schema.get("pattern")
            min_length = schema.get("minLength", 0)
            max_length = schema.get("maxLength", 20)

            default_val = schema.get("default")
            if default_val is not None:
                return default_val

            format_hint = schema.get("format")
            if format_hint == "date-time":
                return "2023-01-01T12:00:00Z"
            if format_hint == "date":
                return "2023-01-01"
            if format_hint == "email":
                return "user@example.com"
            if format_hint == "uri":
                return "https://example.com"
            if format_hint == "uuid":
                return "0e9e4455-f241-4f2f-a70d-90b7ce5fe190"

            if pattern:
                try:
                    strategy = from_regex(pattern)
                    example_str = strategy.example()
                    if min_length and len(example_str) < min_length:
                        example_str = example_str * ((min_length // len(example_str)) + 1)
                    if max_length and len(example_str) > max_length:
                        example_str = example_str[:max_length]
                    return example_str
                except Exception:
                    return f"pattern_match_for_{pattern}"

            s = "example_string"
            if min_length > len(s):
                s = s * ((min_length // len(s)) + 1)
            if max_length and len(s) > max_length:
                s = s[:max_length]
            return s

        if schema_type == "number":
            minimum = schema.get("minimum")
            maximum = schema.get("maximum")
            exclusive_min = schema.get("exclusiveMinimum")
            exclusive_max = schema.get("exclusiveMaximum")

            default_val = schema.get("default")
            if default_val is not None:
                return default_val

            val = 1.0
            if minimum is not None:
                val = float(minimum) + (0.1 if not exclusive_min else 0.001)
            if maximum is not None:
                max_val = float(maximum) - (0.1 if not exclusive_max else 0.001)
                val = min(val, max_val)
            return val

        if schema_type == "integer":
            minimum = schema.get("minimum")
            maximum = schema.get("maximum")
            exclusive_min = schema.get("exclusiveMinimum")
            exclusive_max = schema.get("exclusiveMaximum")

            default_val = schema.get("default")
            if default_val is not None:
                return default_val

            val = 1
            if minimum is not None:
                val = int(minimum) + 1 if exclusive_min else int(minimum)
            if maximum is not None:
                max_val = int(maximum) - 1 if exclusive_max else int(maximum)
                val = min(val, max_val)
            return val

        if schema_type == "boolean":
            default_val = schema.get("default")
            if default_val is not None:
                return default_val
            return True

        if schema_type == "null":
            return None

        return {}

    def validate(self):
        schema_str = self.schema_text_widget.get("1.0", tk.END).strip()
        instance_str = self.instance_text_widget.get("1.0", tk.END).strip()

        if not schema_str or not instance_str:
            messagebox.showwarning("Ошибка", "Пожалуйста, заполните оба поля.")
            return

        try:
            schema = json.loads(schema_str)
        except json.JSONDecodeError as e:
            messagebox.showerror("Ошибка схемы", f"Некорректный формат JSON схемы:\n{e}")
            return

        try:
            instance = json.loads(instance_str)
        except json.JSONDecodeError as e:
            messagebox.showerror("Ошибка сообщения", f"Некорректный формат JSON сообщения:\n{e}")
            return

        try:
            jsonschema.validate(instance=instance, schema=schema)
            self.current_errors = []
            self._render_errors([("info", "$", "Сообщение соответствует схеме.")])
            messagebox.showinfo("Успех", "Сообщение соответствует схеме.")
        except ValidationError as ve:
            validator = jsonschema.Draft7Validator(schema)
            errors = list(validator.iter_errors(instance))
            best_error = best_match(errors) if errors else None

            error_entries: List[DiffEntry] = []
            for err in errors:
                if err.absolute_path:
                    path_str = "$." + ".".join(str(x) for x in err.absolute_path)
                else:
                    path_str = "$"
                error_entries.append(("error", path_str, err.message))

            self.current_errors = error_entries
            self._render_errors(error_entries or [("error", "$", "Неизвестная ошибка валидации.")])

            if not best_error:
                error_details = "Неизвестная ошибка валидации."
            else:
                error_details = "Сообщение не соответствует схеме.\n\n"
                error_details += f"Тип ошибки: {type(ve).__name__}\n"
                error_details += (
                    "Путь к ошибке: "
                    f"{' -> '.join(str(x) for x in best_error.absolute_path) if best_error.absolute_path else 'корень'}\n"
                )
                error_details += f"Сообщение: {best_error.message}\n"

                recommendations = "\n\nРекомендации по исправлению:\n"
                if best_error.validator == "type":
                    recommendations += "- Проверьте тип данных (строка/число/объект и т.д.).\n"
                elif best_error.validator == "required":
                    recommendations += "- Убедитесь, что все обязательные поля присутствуют.\n"
                elif best_error.validator == "enum":
                    allowed = best_error.validator_value
                    recommendations += (
                        f"- Значение должно быть одним из допустимых вариантов: {allowed}\n"
                    )
                elif best_error.validator in ["minLength", "maxLength"]:
                    recommendations += (
                        f"- Проверьте длину строки (ограничение {best_error.validator} = "
                        f"{best_error.validator_value}).\n"
                    )
                elif best_error.validator in ["minimum", "maximum"]:
                    recommendations += (
                        f"- Проверьте числовое значение (ограничение {best_error.validator} = "
                        f"{best_error.validator_value}).\n"
                    )
                elif best_error.validator == "pattern":
                    recommendations += (
                        f"- Значение не соответствует шаблону: {best_error.validator_value}\n"
                    )
                elif best_error.validator == "anyOf":
                    recommendations += (
                        "- Значение не соответствует ни одной из схем в anyOf. Проверьте спецификацию.\n"
                    )
                elif best_error.validator == "oneOf":
                    recommendations += (
                        "- Значение не соответствует ни одной из схем в oneOf. Проверьте спецификацию.\n"
                    )
                elif best_error.validator == "allOf":
                    recommendations += (
                        "- Значение не соответствует всем схемам в allOf. Проверьте спецификацию.\n"
                    )
                else:
                    recommendations += (
                        f"- Ошибка связана с правилом '{best_error.validator}'. "
                        "Проверьте спецификацию схемы.\n"
                    )

                error_details += recommendations

            messagebox.showerror("Ошибка валидации", error_details)

    def save_instance(self):
        content = self.instance_text_widget.get("1.0", tk.END).strip()
        if not content:
            messagebox.showwarning("Ошибка", "Нет данных для сохранения.")
            return

        file_path = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            title="Сохранить сообщение как",
        )
        if not file_path:
            return
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(content)
            messagebox.showinfo("Успех", f"Файл сохранён: {file_path}")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось сохранить файл:\n{e}")

    def _render_errors(self, errors: List[DiffEntry]):
        self.error_text.delete("1.0", tk.END)

        if not errors:
            return

        for idx, (kind, path, msg) in enumerate(errors, start=1):
            line = f"{idx:4d}. [{kind.upper()}] {path}: {msg}\n"
            self.error_text.insert(tk.END, line, (kind,))

            tag_name = f"err_line_{idx}"
            self.error_text.tag_add(tag_name, f"{idx}.0", f"{idx}.end")
            self.error_text.tag_bind(
                tag_name,
                "<Button-1>",
                lambda _event, i=idx - 1: self.on_error_click(i),
            )

    def on_error_click(self, index: int):
        """Клик по строке ошибки: переходим к месту проблемы."""
        if not (0 <= index < len(self.current_errors)):
            return

        _kind, path, _msg = self.current_errors[index]

        self.schema_text_widget.tag_remove("hl", "1.0", tk.END)
        self.instance_text_widget.tag_remove("hl", "1.0", tk.END)

        key = self._extract_key_from_path(path)
        if not key:
            return

        self._highlight_in_widget(self.instance_text_widget, key)
        self._highlight_in_widget(self.schema_text_widget, key)

    @staticmethod
    def _extract_key_from_path(path: str) -> str | None:

        if not path or path == "$":
            return None

        if path.startswith("$."):
            path = path[2:]
        elif path == "$":
            return None

        parts = [p for p in path.split(".") if p]
        if not parts:
            return None

        candidate = parts[-1]
        candidate = candidate.split("[")[0]

        meta_keys = {"type", "required", "properties", "items", "enum", "allOf", "anyOf", "oneOf"}
        if candidate in meta_keys and len(parts) >= 2:
            candidate = parts[-2].split("[")[0]

        return candidate or None

    @staticmethod
    def _highlight_in_widget(widget: tk.Text, key: str):
        """Ищет первое вхождение ключа и подсвечивает соответствующую строку."""
        pattern = f'"{key}"'
        idx = widget.search(pattern, "1.0", tk.END)

        if not idx:
            idx = widget.search(key, "1.0", tk.END)

        if not idx:
            return

        line = idx.split(".")[0]
        line_start = f"{line}.0"
        line_end = f"{line}.end"

        widget.see(line_start)
        widget.tag_add("hl", line_start, line_end)


class SchemaDiffFrame(ttk.Frame):
    """
    Вкладка для семантического сравнения двух JSON-схем.
    """

    def __init__(self, parent: tk.Misc):
        super().__init__(parent)

        self.current_diffs: List[DiffEntry] = []

        main_frame = ttk.Frame(self)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        top_frame = ttk.Frame(main_frame)
        top_frame.pack(fill=tk.X, pady=(0, 10))

        self.left_path_var = tk.StringVar()
        self.right_path_var = tk.StringVar()

        ttk.Label(top_frame, text="Схема 1:").grid(row=0, column=0, sticky="w")
        ttk.Entry(top_frame, textvariable=self.left_path_var, width=40).grid(
            row=0, column=1, sticky="we", padx=(5, 10)
        )
        ttk.Button(top_frame, text="Открыть...", command=self.load_left_schema).grid(
            row=0, column=2, padx=(0, 20)
        )

        ttk.Label(top_frame, text="Схема 2:").grid(row=0, column=3, sticky="w")
        ttk.Entry(top_frame, textvariable=self.right_path_var, width=40).grid(
            row=0, column=4, sticky="we", padx=(5, 10)
        )
        ttk.Button(top_frame, text="Открыть...", command=self.load_right_schema).grid(
            row=0, column=5
        )

        top_frame.columnconfigure(1, weight=1)
        top_frame.columnconfigure(4, weight=1)

        paned = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True)

        left_frame = ttk.Frame(paned)
        right_frame = ttk.Frame(paned)
        paned.add(left_frame, weight=1)
        paned.add(right_frame, weight=1)

        ttk.Label(left_frame, text="JSON Schema 1").pack(anchor=tk.W)
        self.left_code = LineNumberedText(left_frame, wrap=tk.WORD)
        self.left_code.pack(fill=tk.BOTH, expand=True, padx=(0, 5), pady=(5, 5))
        self.left_text = self.left_code.text

        ttk.Label(right_frame, text="JSON Schema 2").pack(anchor=tk.W)
        self.right_code = LineNumberedText(right_frame, wrap=tk.WORD)
        self.right_code.pack(fill=tk.BOTH, expand=True, padx=(5, 0), pady=(5, 5))
        self.right_text = self.right_code.text

        self.left_text.tag_configure("hl", background="#fff8b3")
        self.right_text.tag_configure("hl", background="#fff8b3")

        bottom_frame = ttk.Frame(main_frame)
        bottom_frame.pack(fill=tk.BOTH, expand=True, pady=(10, 0))

        controls_frame = ttk.Frame(bottom_frame)
        controls_frame.pack(fill=tk.X, pady=(0, 5))

        self.compare_button = ttk.Button(
            controls_frame, text="Сравнить схемы", command=self.compare_schemas
        )
        self.compare_button.pack(side=tk.LEFT)

        self.copy_button = ttk.Button(
            controls_frame, text="Копировать результат", command=self.copy_diff
        )
        self.copy_button.pack(side=tk.LEFT, padx=(10, 0))

        ttk.Label(controls_frame, text="  Легенда:").pack(side=tk.LEFT, padx=(20, 0))
        ttk.Label(controls_frame, text="Добавлено  Удалено  Изменено").pack(side=tk.LEFT)

        ttk.Label(bottom_frame, text="Семантические отличия:").pack(anchor=tk.W)
        self.diff_output = LineNumberedText(bottom_frame, wrap=tk.WORD)
        self.diff_output.pack(fill=tk.BOTH, expand=True)
        self.diff_text = self.diff_output.text

        self.diff_text.tag_configure("added", foreground="#006400")  
        self.diff_text.tag_configure("removed", foreground="#8B0000")  
        self.diff_text.tag_configure("changed", foreground="#8B4513")  
        self.diff_text.tag_configure("info", foreground="#000080") 

    def load_left_schema(self):
        path = filedialog.askopenfilename(
            title="Выберите файл JSON схемы 1",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
        )
        if not path:
            return
        self.left_path_var.set(path)
        self._load_file_into_text(path, self.left_text)

    def load_right_schema(self):
        path = filedialog.askopenfilename(
            title="Выберите файл JSON схемы 2",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
        )
        if not path:
            return
        self.right_path_var.set(path)
        self._load_file_into_text(path, self.right_text)

    @staticmethod
    def _load_file_into_text(path: str, widget: scrolledtext.ScrolledText):
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = f.read()
            widget.delete("1.0", tk.END)
            widget.insert(tk.END, content)
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось прочитать файл:\n{e}")

    def compare_schemas(self):
        left_str = self.left_text.get("1.0", tk.END).strip()
        right_str = self.right_text.get("1.0", tk.END).strip()

        if not left_str or not right_str:
            messagebox.showwarning("Внимание", "Пожалуйста, загрузите и/или введите обе схемы.")
            return

        try:
            left_schema = json.loads(left_str)
        except json.JSONDecodeError as e:
            messagebox.showerror("Ошибка", f"Схема 1 не является корректным JSON:\n{e}")
            return

        try:
            right_schema = json.loads(right_str)
        except json.JSONDecodeError as e:
            messagebox.showerror("Ошибка", f"Схема 2 не является корректным JSON:\n{e}")
            return

        diffs: List[DiffEntry] = []
        self._compare_schemas(left_schema, right_schema, path="$", diffs=diffs)

        self.current_diffs = diffs
        self._render_diffs(diffs)

    def _compare_schemas(self, left: Any, right: Any, path: str, diffs: List[DiffEntry]):
        if type(left) is not type(right):
            diffs.append(
                (
                    "changed",
                    path,
                    f"Тип узла изменился: {type(left).__name__} -> {type(right).__name__}",
                )
            )
            return

        if isinstance(left, dict) and isinstance(right, dict):
            left_keys = set(left.keys())
            right_keys = set(right.keys())

            for key in sorted(left_keys - right_keys):
                diffs.append(
                    ("removed", f"{path}.{key}", f"Ключ '{key}' удалён")
                )

            for key in sorted(right_keys - left_keys):
                diffs.append(
                    ("added", f"{path}.{key}", f"Ключ '{key}' добавлен")
                )

            for key in sorted(left_keys & right_keys):
                new_path = f"{path}.{key}"
                if key == "type":
                    if left[key] != right[key]:
                        diffs.append(
                            (
                                "changed",
                                new_path,
                                f"Тип изменился: {left[key]!r} -> {right[key]!r}",
                            )
                        )
                elif key == "required":
                    self._compare_required(left.get(key), right.get(key), new_path, diffs)
                elif key in ("enum", "allOf", "anyOf", "oneOf"):
                    self._compare_list_semantic(
                        left.get(key), right.get(key), new_path, diffs, key
                    )
                elif key == "properties":
                    self._compare_properties(
                        left.get(key) or {}, right.get(key) or {}, new_path, diffs
                    )
                elif key == "items":
                    self._compare_schemas(left.get(key), right.get(key), new_path, diffs)
                else:
                    self._compare_schemas(left.get(key), right.get(key), new_path, diffs)

        elif isinstance(left, list) and isinstance(right, list):
            max_len = max(len(left), len(right))
            for i in range(max_len):
                new_path = f"{path}[{i}]"
                if i >= len(left):
                    diffs.append(
                        ("added", new_path, f"Элемент {right[i]!r} добавлен")
                    )
                elif i >= len(right):
                    diffs.append(
                        ("removed", new_path, f"Элемент {left[i]!r} удалён")
                    )
                else:
                    self._compare_schemas(left[i], right[i], new_path, diffs)

        else:
            if left != right:
                diffs.append(
                    ("changed", path, f"Значение изменилось: {left!r} -> {right!r}")
                )

    def _compare_properties(
        self,
        left_props: Dict[str, Any],
        right_props: Dict[str, Any],
        path: str,
        diffs: List[DiffEntry],
    ):
        left_keys = set(left_props.keys())
        right_keys = set(right_props.keys())

        for key in sorted(left_keys - right_keys):
            diffs.append(
                ("removed", f"{path}.{key}", f"Свойство '{key}' удалено")
            )

        for key in sorted(right_keys - left_keys):
            diffs.append(
                ("added", f"{path}.{key}", f"Свойство '{key}' добавлено")
            )

        for key in sorted(left_keys & right_keys):
            self._compare_schemas(
                left_props[key], right_props[key], f"{path}.{key}", diffs
            )

    def _compare_required(
        self, left_req: Any, right_req: Any, path: str, diffs: List[DiffEntry]
    ):
        left_set = set(left_req or [])
        right_set = set(right_req or [])

        for field in sorted(left_set - right_set):
            diffs.append(
                (
                    "changed",
                    path,
                    f"Поле '{field}' перестало быть обязательным",
                )
            )

        for field in sorted(right_set - left_set):
            diffs.append(
                (
                    "changed",
                    path,
                    f"Поле '{field}' стало обязательным",
                )
            )

    def _compare_list_semantic(
        self,
        left_list: Any,
        right_list: Any,
        path: str,
        diffs: List[DiffEntry],
        list_kind: str,
    ):
        left_list = left_list or []
        right_list = right_list or []

        if list_kind == "enum":
            left_set = set(left_list)
            right_set = set(right_list)

            for v in sorted(left_set - right_set):
                diffs.append(
                    ("removed", path, f"Значение {v!r} удалено из enum")
                )
            for v in sorted(right_set - left_set):
                diffs.append(
                    ("added", path, f"Значение {v!r} добавлено в enum")
                )
        else:
            max_len = max(len(left_list), len(right_list))
            for i in range(max_len):
                new_path = f"{path}[{i}]"
                if i >= len(left_list):
                    diffs.append(
                        ("added", new_path, f"Элемент добавлен в {list_kind}")
                    )
                elif i >= len(right_list):
                    diffs.append(
                        ("removed", new_path, f"Элемент удалён из {list_kind}")
                    )
                else:
                    self._compare_schemas(left_list[i], right_list[i], new_path, diffs)

    def _render_diffs(self, diffs: List[DiffEntry]):
        self.diff_text.delete("1.0", tk.END)

        if not diffs:
            self.diff_text.insert(
                tk.END, "Схемы логически эквивалентны.\n", ("info",)
            )
            return

        for idx, (kind, path, msg) in enumerate(diffs, start=1):
            line = f"{idx:4d}. [{kind.upper()}] {path}: {msg}\n"
            self.diff_text.insert(tk.END, line, (kind,))

            tag_name = f"diff_line_{idx}"
            self.diff_text.tag_add(tag_name, f"{idx}.0", f"{idx}.end")
            self.diff_text.tag_bind(
                tag_name,
                "<Button-1>",
                lambda _event, i=idx - 1: self.on_diff_click(i),
            )

    def copy_diff(self):
        text = self.diff_text.get("1.0", tk.END).strip()
        if not text:
            messagebox.showwarning("Копирование", "Нет данных для копирования.")
            return
        root = self.winfo_toplevel()
        root.clipboard_clear()
        root.clipboard_append(text)
        messagebox.showinfo("Копирование", "Результат различий скопирован в буфер обмена.")

    def on_diff_click(self, index: int):
        """Обработчик клика по строке с отличием: переходит и подсвечивает место в схеме."""
        if not (0 <= index < len(self.current_diffs)):
            return

        kind, path, _msg = self.current_diffs[index]

        self.left_text.tag_remove("hl", "1.0", tk.END)
        self.right_text.tag_remove("hl", "1.0", tk.END)

        targets: List[tk.Text] = []
        if kind == "added":
            targets = [self.right_text]
        elif kind == "removed":
            targets = [self.left_text]
        else: 
            targets = [self.left_text, self.right_text]

        key = self._extract_key_from_path(path)
        if not key:
            return

        for widget in targets:
            self._highlight_in_widget(widget, key)

    @staticmethod
    def _extract_key_from_path(path: str) -> str | None:

        if not path or path == "$":
            return None

        parts = [p for p in path.split(".") if p and p != "$"]
        if not parts:
            return None

        candidate = parts[-1]
        candidate = candidate.split("[")[0]

        meta_keys = {"type", "required", "properties", "items", "enum", "allOf", "anyOf", "oneOf"}
        if candidate in meta_keys and len(parts) >= 2:
            candidate = parts[-2].split("[")[0]

        return candidate or None

    def _highlight_in_widget(self, widget: tk.Text, key: str):
        """
        Ищет первое вхождение ключа и подсвечивает соответствующую строку.
        """
        pattern = f'"{key}"'
        idx = widget.search(pattern, "1.0", tk.END)

        if not idx:
            idx = widget.search(key, "1.0", tk.END)

        if not idx:
            return

        line_start = f"{idx.split('.')[0]}.0"
        line_end = f"{idx.split('.')[0]}.end"

        widget.see(line_start)
        widget.tag_add("hl", line_start, line_end)


def main():
    root = tk.Tk()
    root.title("JSON Schema Tools")
    root.geometry("1200x800")

    notebook = ttk.Notebook(root)
    notebook.pack(fill=tk.BOTH, expand=True)

    schema_tools_tab = SchemaToolsFrame(notebook)
    diff_tab = SchemaDiffFrame(notebook)

    notebook.add(schema_tools_tab, text="Генерация / Проверка")
    notebook.add(diff_tab, text="Сравнение схем")

    root.mainloop()


if __name__ == "__main__":
    main()
